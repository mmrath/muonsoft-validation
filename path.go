package validation

import (
	"fmt"
	"strconv"
	"strings"
	"unicode"
)

// PropertyPathElement is a part of the PropertyPath.
type PropertyPathElement interface {
	// IsIndex can be used to determine whether an element is a string (property name) or
	// an index array.
	IsIndex() bool
	fmt.Stringer
}

// PropertyName holds up property name value under PropertyPath.
type PropertyName string

// IsIndex on PropertyName always returns false.
func (p PropertyName) IsIndex() bool {
	return false
}

// String returns property name as is.
func (p PropertyName) String() string {
	return string(p)
}

// ArrayIndex holds up array index value under PropertyPath.
type ArrayIndex int

// IsIndex on ArrayIndex always returns true.
func (a ArrayIndex) IsIndex() bool {
	return true
}

// String returns array index values converted into a string.
func (a ArrayIndex) String() string {
	return strconv.Itoa(int(a))
}

// PropertyPath is generated by the validator and indicates how it reached the invalid value
// from the root element. Property path is denoted by dots, while array access
// is denoted by square brackets. For example, "book.keywords[0]" means that the violation
// occurred on the first element of array "keywords" in the "book" object.
//
// Internally PropertyPath is a linked list. You can create a new path using WithProperty
// or WithIndex methods. PropertyPath should always be used as a pointer value.
// Nil value is a valid value that means that the property path is empty.
type PropertyPath struct {
	parent *PropertyPath
	value  PropertyPathElement
}

// NewPropertyPath creates a PropertyPath from the list of elements. If the list is empty nil will be returned.
// Nil value is a valid value that means that the property path is empty.
func NewPropertyPath(elements ...PropertyPathElement) *PropertyPath {
	var path *PropertyPath

	return path.With(elements...)
}

// With returns new PropertyPath with appended elements to the end of the list.
func (path *PropertyPath) With(elements ...PropertyPathElement) *PropertyPath {
	current := path
	for _, element := range elements {
		current = &PropertyPath{parent: current, value: element}
	}
	return current
}

// WithProperty returns new PropertyPath with appended PropertyName to the end of the list.
func (path *PropertyPath) WithProperty(name string) *PropertyPath {
	return &PropertyPath{
		parent: path,
		value:  PropertyName(name),
	}
}

// WithIndex returns new PropertyPath with appended ArrayIndex to the end of the list.
func (path *PropertyPath) WithIndex(index int) *PropertyPath {
	return &PropertyPath{
		parent: path,
		value:  ArrayIndex(index),
	}
}

// String is used to format property path to a string.
func (path *PropertyPath) String() string {
	elements := make([]PropertyPathElement, 0, 8)
	element := path
	count := 0
	for element != nil {
		if s, ok := element.value.(PropertyName); ok {
			count += len(s)
		} else {
			count += 2
		}
		elements = append(elements, element.value)
		element = element.parent
	}

	s := strings.Builder{}
	s.Grow(count)
	for i := len(elements) - 1; i >= 0; i-- {
		name := elements[i].String()
		if elements[i].IsIndex() {
			s.WriteString("[" + name + "]")
		} else if isIdentifier(name) {
			if i < len(elements)-1 {
				s.WriteString(".")
			}
			s.WriteString(name)
		} else {
			s.WriteString("['")
			writePropertyName(&s, name)
			s.WriteString("']")
		}
	}

	return s.String()
}

// MarshalText will marshal property path value to a string.
func (path *PropertyPath) MarshalText() (text []byte, err error) {
	return []byte(path.String()), nil
}

func isIdentifier(s string) bool {
	if len(s) == 0 {
		return false
	}
	for i, c := range s {
		if i == 0 && !unicode.IsLetter(c) {
			return false
		}
		if i > 0 && !unicode.IsLetter(c) && !unicode.IsDigit(c) {
			return false
		}
	}

	return true
}

func writePropertyName(s *strings.Builder, name string) {
	for _, c := range name {
		if c == '\'' || c == '\\' {
			s.WriteRune('\\')
		}
		s.WriteRune(c)
	}
}
